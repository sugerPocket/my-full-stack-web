{"meta":{"title":"Sugerpocket","subtitle":null,"description":null,"author":"sugerpocket","url":"http://sugerpocket.github.io"},"pages":[{"title":"关于本站","date":"2017-12-20T19:23:29.497Z","updated":"2017-12-20T19:23:29.497Z","comments":true,"path":"about/index.html","permalink":"http://sugerpocket.github.io/about/index.html","excerpt":"","text":"sugerpocket中山大学 2015 级软件工程专业在读本科生研究兴趣 web前端 web设计 可用性设计 爱好 绘画 视频 ACG 优点无 缺点弱鸡"},{"title":"Categories","date":"2017-12-20T17:06:29.618Z","updated":"2017-12-20T17:06:29.617Z","comments":true,"path":"categories/index.html","permalink":"http://sugerpocket.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-12-20T17:06:29.619Z","updated":"2017-12-20T17:06:29.619Z","comments":true,"path":"tags/index.html","permalink":"http://sugerpocket.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"浅析 event loop 事件队列 microTask 和 macroTask 的区别","slug":"event-loop","date":"2018-01-05T05:18:16.000Z","updated":"2018-01-05T06:34:21.000Z","comments":true,"path":"2018/01/05/event-loop/","link":"","permalink":"http://sugerpocket.github.io/2018/01/05/event-loop/","excerpt":"javascript 是单线程的，但是如果遇到了不得不等待的任务，js 引擎并不会阻塞进程，而是异步地将任务添加到队列，不阻塞主进程，使得主进程可以先执行其他任务，等到进程空闲，再检查任务队列，本篇就 js 中的事件循环机制与任务队列调度的细节进行探讨。","text":"javascript 是单线程的，但是如果遇到了不得不等待的任务，js 引擎并不会阻塞进程，而是异步地将任务添加到队列，不阻塞主进程，使得主进程可以先执行其他任务，等到进程空闲，再检查任务队列，本篇就 js 中的事件循环机制与任务队列调度的细节进行探讨。 实际上，js 引擎并不只维护一个任务队列，总共有三种任务 Task(macroTask): setTimeout, setInterval, setImmediate, I/O, UI rendering microTask: Promise, process.nextTick, Object.observe, MutationObserver, MutaionObserver 按照一般（之前的理解），这些函数都只是添加任务到队列里面，似乎并无差别 看这段经典代码，体会一下 123456789101112131415setTimeout(function() &#123; console.log(4);&#125;, 0);var promise = new Promise(function executor(resolve) &#123; console.log(1); for (var i = 0; i &lt; 10000; i++) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(2);&#125;).then(function() &#123; console.log(5);&#125;);console.log(3); 简单的 event-loop 理解，答案是 12345 好吧，错了，答案是 12354 这说明 Promise.then 注册的任务先执行了，why？ 我们再来看一下之前说的 Promise 注册的任务属于 microTask，setTimeout 属于 Task，两者有何差别？ 好吧，实际上，microTasks 和 Tasks 并不在同一个队列里面，他们的调度机制也不相同。比较具体的是这样： 个人总结，参考资料在文章末尾，有错误欢迎指正 event-loop start microTasks 队列开始清空（执行） 检查 Tasks 是否清空，有则跳到 4，无则跳到 6 从 Tasks 队列抽取一个任务，执行 检查 microTasks 是否清空，若有则跳到 2，无则跳到 3 结束 event-loop 好，也就是说，microTasks 队列在一次事件循环里面不止检查一次，我们做个实验 12345678910111213141516171819202122232425262728293031// 添加三个 Task// Task 1setTimeout(function() &#123; console.log(4);&#125;, 0);// Task 2setTimeout(function() &#123; console.log(6); // 添加 microTask promise.then(function() &#123; console.log(8); &#125;);&#125;, 0);// Task 3setTimeout(function() &#123; console.log(7);&#125;, 0);var promise = new Promise(function executor(resolve) &#123; console.log(1); for (var i = 0; i &lt; 10000; i++) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(2);&#125;).then(function() &#123; console.log(5);&#125;);console.log(3); 以上这段代码在开始添加三个任务到 Tasks 里面，并且第二个 task 会添加一个 microTask 预测一下结果： 若每次执行一个 task 都会检查 microTask 队列，那么 microTask 会先于 task 3 执行，8 将会先于 7 输出，结果应该为 12354687 如果只检查一遍 microTasks，那么 8 将于下一次 event-loop 输出，也就是最后输出，结果应该为 12354678 毫无疑问，结果是前者（仔细阅读那段简单的测试代码，理解一下，复制粘贴试试结果，没有图片难以形象地描述） 结论就是，microTasks 会在每个 Task 执行完毕之后检查清空，而这次 event-loop 的新 task 会在下次 event-loop 检测。 对于大部分开发者来说，异步队列就好似不存在一般，我们只管用就可以了，有一定经验的人会了解事件循环，任务队列，但是很少人知道他们的实现细节，虽然这对开发来说无关紧要，但理解基础的东西会帮助开发者更好地解决问题（或许哪一天就踩到了坑呢）。 参考https://juejin.im/entry/58332d560ce46300610e4badhttps://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/https://flyyang.github.io/2017/03/07/javascript%E4%B8%AD%E7%9A%84microtask%E4%B8%8Etask/https://hao5743.github.io/2017/02/27/%E5%AF%B9node%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E4%B8%ADMacrotask%E5%92%8CMicrotask%E7%9A%84%E7%90%86%E8%A7%A3/https://github.com/ccforward/cc/issues/48https://github.com/creeperyang/blog/issues/21https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop","categories":[],"tags":[{"name":"web前端","slug":"web前端","permalink":"http://sugerpocket.github.io/tags/web前端/"},{"name":"nodejs","slug":"nodejs","permalink":"http://sugerpocket.github.io/tags/nodejs/"},{"name":"javascript","slug":"javascript","permalink":"http://sugerpocket.github.io/tags/javascript/"}]},{"title":"learn-shadow-DOM","slug":"learn-shadow-DOM","date":"2017-12-26T14:30:38.000Z","updated":"2018-01-05T04:59:41.995Z","comments":true,"path":"2017/12/26/learn-shadow-DOM/","link":"","permalink":"http://sugerpocket.github.io/2017/12/26/learn-shadow-DOM/","excerpt":"Shadow DOM 是新一代 Web 组件化解决方案，将 DOM 与 CSS 封装，使其与主 DOM 分离。开发人员可以很轻易地在外部使用组件，而不用在意操作是否影响它。MDN | Shadow DOM","text":"Shadow DOM 是新一代 Web 组件化解决方案，将 DOM 与 CSS 封装，使其与主 DOM 分离。开发人员可以很轻易地在外部使用组件，而不用在意操作是否影响它。MDN | Shadow DOM 特别详细的文章","categories":[{"name":"web前端","slug":"web前端","permalink":"http://sugerpocket.github.io/categories/web前端/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"http://sugerpocket.github.io/tags/web前端/"},{"name":"html","slug":"html","permalink":"http://sugerpocket.github.io/tags/html/"},{"name":"js","slug":"js","permalink":"http://sugerpocket.github.io/tags/js/"}]},{"title":"CSS 前端面试题汇总","slug":"css-interview-quiz","date":"2017-12-20T19:11:03.000Z","updated":"2017-12-20T19:15:30.228Z","comments":true,"path":"2017/12/21/css-interview-quiz/","link":"","permalink":"http://sugerpocket.github.io/2017/12/21/css-interview-quiz/","excerpt":"收集 css 面试题，阅读 《CSS权威指南》，为来年春招做准备","text":"收集 css 面试题，阅读 《CSS权威指南》，为来年春招做准备","categories":[{"name":"web前端","slug":"web前端","permalink":"http://sugerpocket.github.io/categories/web前端/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"http://sugerpocket.github.io/tags/web前端/"},{"name":"css3","slug":"css3","permalink":"http://sugerpocket.github.io/tags/css3/"},{"name":"css","slug":"css","permalink":"http://sugerpocket.github.io/tags/css/"},{"name":"面试","slug":"面试","permalink":"http://sugerpocket.github.io/tags/面试/"}]},{"title":"js 前端面试题汇总","slug":"javascript-interview-quiz","date":"2017-12-20T19:11:03.000Z","updated":"2017-12-20T19:18:32.611Z","comments":true,"path":"2017/12/21/javascript-interview-quiz/","link":"","permalink":"http://sugerpocket.github.io/2017/12/21/javascript-interview-quiz/","excerpt":"收集 js 面试题，阅读犀牛书与红宝书，为来年春招做准备","text":"收集 js 面试题，阅读犀牛书与红宝书，为来年春招做准备","categories":[{"name":"web前端","slug":"web前端","permalink":"http://sugerpocket.github.io/categories/web前端/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"http://sugerpocket.github.io/tags/web前端/"},{"name":"面试","slug":"面试","permalink":"http://sugerpocket.github.io/tags/面试/"},{"name":"es6","slug":"es6","permalink":"http://sugerpocket.github.io/tags/es6/"},{"name":"js","slug":"js","permalink":"http://sugerpocket.github.io/tags/js/"}]},{"title":"html 前端面试题汇总","slug":"html-interview-quiz","date":"2017-12-20T18:16:24.000Z","updated":"2017-12-21T09:00:24.763Z","comments":true,"path":"2017/12/21/html-interview-quiz/","link":"","permalink":"http://sugerpocket.github.io/2017/12/21/html-interview-quiz/","excerpt":"个人收集的 web 前端 html 面试题, 为来年春招做准备, 仅供参考.","text":"个人收集的 web 前端 html 面试题, 为来年春招做准备, 仅供参考. 2017/12/21 1. &lt;meta&gt; 标签与其作用更详细请参考 &lt;meta&gt; - HTML（超文本标记语言） | MDN 属性charset 声明文档所使用的字符编码 默认 ASCII (推荐 UTF-8) content 为 http-equiv 或者 name 提供值 http-equiv 预定义 http 响应头 枚举值： “content-security-policy”内容安全策略详情参考 content-security-policy | MDN. “content-type”指定默认的响应 MIME 类型 “default-style”规定要使用的预定义的样式表。(其 content 的值必须是同一文档下某个 link 的 title 值) “refresh”定义文档自动刷新的时间间隔（个人不清楚有什么用） name 不可与 charset, itemprop, http-equiv 同时使用于一个 meta 之上 枚举值: application-name:定义运行在网页上的具体应用名称，与 title 不同 author:文档作者 desscription:关于页面内容的简短描述 generator:表明生成这个页面的应用程序 keywords:描述网站的关键字 referrer:控制所有从该文档发出的 HTTP 请求中HTTP Referer 首部的内容： 1&lt;meta name=\"referrer\"&gt; 动态插入 referrer 是没有作用的，\b定义冲突会采用 no-referer 策略 content 属性可取的值： \b no-referrer 不要发送 HTTP Referer 首部。 origin 发送当前文档的 origin。 no-referrer-when-downgrade 当目的地是先验安全的(https-&gt;https)则发送 origin 作为 referrer ，但是当目的地是较不安全的 (https-&gt;http)时则不发送 referrer 。这个是默认的行为。 origin-when-crossorigin 在同源请求下，发送完整的URL (不含查询参数) ，其他情况下则仅发送当前文档的 origin。 unsafe-URL 在同源请求下，发送完整的URL (不含查询参数)。 viewportviewport 控制布局 | MDN属性值： value 可能值 描述 width 一个正整数或者字符串 device-width defines the width, in pixels, of the viewport height 一个正整数或者字符串 device-height defines the height, in pixels, of the viewport initial-scale 一个0.0 到10.0之间的正数 defines the ratio between the device width (device-width in portrait mode or device-height in landscape mode) and the viewport size. maximum-scale 一个0.0 到10.0之间的正数 defines the maximum value of the zoom; it must be greater or equal to the minimum-scale or the behavior is indeterminate. minimum-scale 一个0.0 到10.0之间的正数 defines the minimum value of the zoom; it must be smaller or equal to the maximum-scale or the behavior is indeterminate. user-scalable 一个布尔值（yes 或者no） If set to no, the user is not able to zoom in the webpage. Default value is yes. robots:定义爬虫如何索引以及处理该页面 总结meta 标签为文档定义一系列元数据，预定义浏览器的行为，\b对 SEO 优化有很大帮助。 2. SEO 优化需要注意的地方有什么 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标 3. DOCTYPE &lt;!doctype&gt;声明必须处于HTML文档的头部，在&lt;html&gt;标签之前，HTML5中不区分大小写 &lt;!doctype&gt;声明不是一个HTML标签，是一个用于告诉浏览器当前HTMl版本的指令 现代浏览器的html布局引擎通过检查doctype决定使用兼容模式还是标准模式对文档进行渲染，一些浏览器有一个接近标准模型。 在HTML4.01中&lt;!doctype&gt;声明指向一个DTD，由于HTML4.01基于SGML，所以DTD指定了标记规则以保证浏览器正确渲染内容 HTML5不基于SGML，所以不用指定DTD，使用 &lt;!DOCTYPE html&gt; 就可以声明","categories":[{"name":"web前端","slug":"web前端","permalink":"http://sugerpocket.github.io/categories/web前端/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"http://sugerpocket.github.io/tags/web前端/"},{"name":"面试","slug":"面试","permalink":"http://sugerpocket.github.io/tags/面试/"},{"name":"html","slug":"html","permalink":"http://sugerpocket.github.io/tags/html/"},{"name":"html5","slug":"html5","permalink":"http://sugerpocket.github.io/tags/html5/"}]}]}